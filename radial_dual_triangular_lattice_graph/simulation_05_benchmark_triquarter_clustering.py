# =============================================================================
# The Tri-Quarter Framework: Radial Dual Triangular Lattice Graphs with Exact
# Bijective Dualities and Equivariant Encodings via the Inversive Hexagonal
# Dihedral Symmetry Group T_24
#
# Simulation 05: Benchmarking Symmetry-Reduced Clustering on the Radial Dual
# Triangular Lattice Graph
#
# Author: Nathan O. Schmidt
# Affiliation: Cold Hammer Research & Development LLC, Eagle, Idaho, USA
# Email: nate.o.schmidt@coldhammer.net
# Date: September 28, 2025
#
# Description:
# This Python script benchmarks the symmetry-reduced average local clustering
# coefficient computation on the truncated radial dual triangular lattice graph
# Lambda_r^R using the order-6 rotational symmetry of the cyclic subgroup Z_6
# The script precomputes Z_6 orbits once, computes clustering coefficients on orbit
# representatives (approximately |V|/6 vertices), and replicates results across
# orbits via group actions to demonstrate up to ~9.6x speedups over the standard
# full-graph recomputation approach.
#
# The clustering coefficient measures local triangle density in vertex
# neighborhoods, preserved under the rotational symmetry for equivariant
# computation. This leverages phase pair constancy along graph rays and the
# angular sector partitioning for efficient symmetry exploitation in graph
# analysis tasks like motif counting or network optimization.
#
# Requirements:
# - Python 3.x
# - NetworkX library (install via: pip install networkx)
#
# Usage:
# Run the script with: python simulation_05_benchmark_triquarter_clustering.py
# [R] [--runs N] [--timing_repeats M]
# where R is the truncation radius (default: 10), --runs N is the number of
# benchmark runs (default: 20), and --timing_repeats M is the repeats per run
# for noise reduction (default: 100).
#
# Source code is freely available at:
# https://github.com/nathanoschmidt/tri-quarter-toolbox/
# (MIT License; see repository LICENSE for details)
#
# =============================================================================

import networkx as nx
import time
import random
import argparse
import statistics
from radial_dual_triangular_lattice_graph import build_complete_lattice_graph, lattice_rotate

def get_symmetry_orbits(G, debug=False):
    # Compute Z_6 orbits for each vertex under order-6 rotational symmetry
    # (generated by rotations R_{k pi/3} for k in Z_6), excluding already
    # visited vertices to partition the graph into disjoint orbits.
    # This precomputation enables symmetry-reduced analysis by processing
    # one representative per orbit and replicating via group actions.
    visited = set()
    orbits = []
    for node in list(G.nodes()):
        if node in visited: continue
        # Unpack lattice coordinates (m, n) and zone type from node tuple
        m, n, node_type = node
        orbit = [node]
        # Generate the orbit by applying rotations k=1 to 5 (k=0 is the node itself)
        for k in range(1, 6):
            # Apply lattice rotation to coordinates (preserves norm and structure)
            rot_m, rot_n = lattice_rotate(m, n, k)
            # Construct rotated node with same zone type
            rot_node = (rot_m, rot_n, node_type)
            if rot_node in G.nodes() and rot_node not in visited:  # Only add if exists and unvisited
                orbit.append(rot_node)
                visited.add(rot_node)
        # Mark original node as visited (before adding orbit)
        visited.add(node)
        # Always add the orbit (includes size-1 for inner/asymmetric cases)
        orbits.append(orbit)
    if debug:
        total_weight = sum(len(set(o)) for o in orbits)
        print(f"Debug: {len(orbits)} orbits, avg size {total_weight / len(orbits):.2f}, coverage {total_weight == len(G)}")
    return orbits

def compute_clustering_on_rep(G, rep):
    # Compute the local clustering coefficient for a representative vertex
    # (triangle density in its neighborhood), which is preserved under Z_6
    # rotations for equivariant replication across the orbit.
    neigh = list(G.neighbors(rep))  # Get adjacent vertices (degree-6 in lattice)
    deg = len(neigh)
    if deg < 2: return 0.0  # No triangles possible for deg < 2
    # Count common neighbors (triangles) by checking edges between pairs
    common = sum(1 for i in range(deg) for j in range(i+1, deg)
                 if G.has_edge(neigh[i], neigh[j]))
    # Standard formula: 2 * triangles / (deg * (deg - 1))
    return (2 * common) / (deg * (deg - 1))

def compute_average_clustering_triquarter(G, orbits):
    # Compute the average clustering coefficient using symmetry reduction:
    # sum over orbits of (clustering on rep * orbit size) / total weight.
    # This exploits rotational invariance to avoid recomputing on full graph.
    total_clust = 0.0
    total_weight = 0
    for orbit in orbits:
        rep = orbit[0]  # Select first node as orbit representative
        clust_rep = compute_clustering_on_rep(G, rep)
        # Deduplicate for fixed points under rotation (e.g., on symmetry axes)
        orbit_size = len(set(orbit))
        # Accumulate weighted sum (preserves equivariance under group action)
        total_clust += clust_rep * orbit_size
        total_weight += orbit_size
    # Return average (zero if no vertices)
    return total_clust / total_weight if total_weight > 0 else 0.0

def benchmark_triquarter_clustering(G, runs, timing_repeats, seed=42, debug=False):
    random.seed(seed)
    # Run benchmark for symmetry-reduced clustering: precompute orbits once,
    # then time repeated average computations for statistical reliability.
    # Precompute orbits outside the timing loop (amortized cost)
    orbits = get_symmetry_orbits(G, debug=debug)
    times = []
    for _ in range(runs):
        t0 = time.perf_counter()  # Start high-resolution timer
        for _ in range(timing_repeats):
            # Use precomputed orbits for efficient equivariant computation
            _ = compute_average_clustering_triquarter(G, orbits)
        # Record average time per repeat in milliseconds
        times.append((time.perf_counter() - t0) * 1000 / timing_repeats)
    # Return mean and standard deviation
    return statistics.mean(times), statistics.stdev(times)

if __name__ == "__main__":
    # Parse command-line arguments for configurable benchmarking
    parser = argparse.ArgumentParser(
        description="Benchmark symmetry-reduced clustering on Lambda_r^R.")
    parser.add_argument("R", type=int, nargs="?", default=10)
    parser.add_argument("--runs", type=int, default=20)
    parser.add_argument("--timing_repeats", type=int, default=100)
    parser.add_argument("--debug", action="store_true", help="Print orbit stats")
    args = parser.parse_args()

    # Build the complete truncated radial dual triangular lattice graph
    # (includes inner, boundary, and outer zones with twin edges)
    G, _ = build_complete_lattice_graph(args.R)
    # Report total vertex count for reference
    num_v = len(G.nodes())
    print(f"Graph: |V|={num_v}")

    # Execute benchmark and print results (mean +/- std dev in ms)
    avg, std = benchmark_triquarter_clustering(
        G, args.runs, args.timing_repeats, debug=args.debug)
    print(f"Tri-Quarter: {avg:.2f} ms +/- {std:.2f}")
