# Tri-Quarter Toolbox

This repository contains Python simulation scripts for the Tri-Quarter framework, as described in the paper "The Tri-Quarter Framework: Radial Dual Triangular Lattice Graph with Combinatorial Duality, Reflective Duality, Bijective Self-Duality, and Equivariant Encodings" by Nathan O. Schmidt (2025). The scripts demonstrate key concepts such as radial dual lattice graphs, circle inversion for path mirroring, and benchmarking of duality-based optimizations.

The framework focuses on mathematical and computational structures for efficient graph traversals, symmetries, and bijective mappings in triangular lattices, with applications in areas like robotics, network optimization, and quantum-inspired simulations.

## Table of Contents

- [Requirements](#requirements)
- [Installation](#installation)
- [Scripts Overview](#scripts-overview)
- [Usage](#usage)
- [Examples](#examples)
- [Contributing](#contributing)
- [License](#license)
- [Citation](#citation)
- [Contact](#contact)

## Requirements

- **Python Version:** Python 3.8 or higher (tested on 3.12.3).
- **Dependencies:**
  - Pygame: For graphical visualization in the dynamic simulation.
  - NetworkX: For graph construction and path computations in benchmarking scripts.
  - Standard libraries: `math`, `random`, `time`, `argparse`, `statistics` (included in Python standard library).

No additional hardware is required beyond a standard computer with a graphical interface (e.g., Windows, macOS, or Linux with X11). Internet access is not needed for running the scripts.

## Installation

1. Clone the repository:
   ```
   git clone https://github.com/nathanoschmidt/tri-quarter-toolbox.git
   cd tri-quarter-toolbox
   ```

2. Install dependencies using pip (works on Windows, Linux, and macOS):
   ```
   pip install pygame networkx
   ```

If using a virtual environment (recommended):
   ```
   python -m venv venv
   source venv/bin/activate  # On Linux/macOS
   venv\Scripts\activate     # On Windows
   pip install pygame networkx
   ```

## Scripts Overview

- **simulation_01_visualize_random_connections.py**: Animates random adjacent paths in the outer zone of the radial dual triangular lattice graph, mirroring them to the inner zone via circle inversion. Updates every 5 seconds to demonstrate reflective duality dynamically.
- **triangular_lattice_graph.py**: Utility script to generate truncated radial dual triangular lattice graphs, including outer/inner zones and the inversion bijection map. Used by the benchmarking scripts.
- **simulation_02_benchmark_standard_path_mirroring.py**: Benchmarks the standard (recompute) approach to shortest-path mirroring in dual zones, serving as a baseline.
- **simulation_03_benchmark_triquarter_path_mirroring.py**: Benchmarks the Tri-Quarter duality approach to path mirroring, using bijection for efficiency gains.
- **get_vertex_counts.py**: Utility script to compute vertex counts in outer, inner, boundary zones, and per angular sector for given inversion radius r and truncation radius R. Validates r_sq for lattice points and outputs breakdowns to console.

All scripts are self-contained and can be run independently, with configurable parameters via command-line arguments where applicable.

## Usage

### Running the Visualization Script
Execute directly:
```
python simulation_01_visualize_random_connections.py
```
- The window displays the lattice with animated random paths (3-5 vertices) in red (outer) and blue (inner via inversion).
- Press the close button to exit.

### Building Graphs (Utility)
This script defines the function `build_radial_dual_triangular_lattice_graph(R, r_sq=1)` for generating graphs. It is typically imported by other scripts but can be used standalone in a test script or interactive session (e.g., IPython/Jupyter). The optional `r_sq` parameter sets the squared inversion radius (default: 1; use integers with lattice points like 7 for denser boundaries).

To test, create a file `test_graph.py` with:
```
from triangular_lattice_graph import build_radial_dual_triangular_lattice_graph

# Build with default r_sq=1
G_outer, G_inner, inversion_map = build_radial_dual_triangular_lattice_graph(10)
print(f"Outer vertices: {len(G_outer.nodes())}")

# Build with optional r_sq=7 (denser boundary)
G_outer, G_inner, inversion_map = build_radial_dual_triangular_lattice_graph(10, r_sq=7)
print(f"Outer vertices with r_sq=7: {len(G_outer.nodes())}")
```
Run: `python test_graph.py`

### Vertex Counting in Graph Zones and Angular Sectors (Utility)
Run the script with inversion radius r (floats accepted; rounds r^2 to nearest valid integer with lattice points) and truncation radius R:
```
python get_vertex_counts.py [r] [R]
```
Example:
```
python get_vertex_counts.py 1 10
```
This computes counts for r≈1 (r^2=1), R=10, printing totals and per-sector averages.

If r^2 has no lattice points, suggests nearest valid values.

### Running Benchmark Scripts
Both benchmark scripts support command-line arguments for truncation radius (`R`), number of runs, and timing repeats.

- Standard approach:
  ```
  python simulation_02_benchmark_standard_path_mirroring.py [R] --runs [NUM] --timing_repeats [NUM]
  ```
  Example: `python simulation_02_benchmark_standard_path_mirroring.py 10 --runs 20 --timing_repeats 100`

- Tri-Quarter approach:
  ```
  python simulation_03_benchmark_triquarter_path_mirroring.py [R] --runs [NUM] --timing_repeats [NUM]
  ```
  Example: `python simulation_03_benchmark_triquarter_path_mirroring.py 15 --runs 20 --timing_repeats 100`

Outputs include graph sizes and average benchmark times in milliseconds (ms) with standard deviation.

## Examples

- Visualize with default settings:
  ```
  python simulation_01_visualize_random_connections.py
  ```

- Benchmark standard mirroring for R=5:
  ```
  python simulation_02_benchmark_standard_path_mirroring.py 5
  ```

- Compare Tri-Quarter speedup for R=15:
  ```
  python simulation_03_benchmark_triquarter_path_mirroring.py 15
  ```

- Count vertices for r≈√7 (r_sq=7), R=20:
  ```
  python get_vertex_counts.py 2.64575 20
  ```

- Generate graphs with optional r_sq (in a test script as above):
  ```
  python test_graph.py
  ```

Results will print to the console, e.g., "Standard Path Mirroring (Recompute): 7.70 ms (+/-0.50)".

## Contributing

Contributions are welcome! Please fork the repository and submit a pull request with improvements, bug fixes, or additional simulations. Ensure code follows PEP 8 style and includes tests where possible.

- Report issues via GitHub Issues.
- For major changes, open an issue first to discuss.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Citation

If you use this toolbox in your research, please cite this work.

The source code is available at: https://github.com/nathanoschmidt/tri-quarter-toolbox/

## Contact

- Author: Nathan O. Schmidt
- Email: nate.o.schmidt@coldhammer.net
- GitHub: [nathanoschmidt](https://github.com/nathanoschmidt)

For questions or collaborations, feel free to open an issue or reach out directly.
